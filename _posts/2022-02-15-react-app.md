---
title: "Hosting a React App with OpenFaaS"
description: "Alex walks you through how to deploy a React App as an OpenFaaS Function."
date: 2022-02-15
image: https://blog.alexellis.io/content/images/2021/03/EwJYydzXIAUktgL.jpeg
categories:
- nodejs
- reactjs
- frontend
author_staff_member: alex
dark_background: true

---

Alex walks you through how to deploy a React App as an OpenFaaS Function.

## A front end served by a function?

React is JavaScript a library and ecosystem used to build front-end applications - web portals, news feeds, blogs, even mobile apps.

Developers usually write code in JSX format, which is transpiled into JavaScript and then served to the browser. The React app runs on the client side, and having a server-side component is completely optional.

This makes it a prime candidate for hosting in OpenFaaS. Any React App deployed as a function can take advantage of the ecosystem:

* event-connectors from Kafka, AWS SQS, NATS, cron, etc
* auto-scaling based upon CPU, RPS or inflight requests
* simple deployment process and central management API 
* automated metrics collection and monitoring

**Static apps**

When a React App has no back-end API to call, making it into a function is a two-stage process:

* Transpile the React JSX files into JavaScript and HTML files
* Serve the static files to clients over HTTP

**Static app with a backend**

There certainly are use-cases for React Apps without any kind of back-end API, but it's more popular to have some kind of persistent storage too. That's where being able to call back into a server-side component makes a lot of sense.

Then you have three stages required:

* Transpile the React JSX files into JavaScript and HTML files
* Serve the static files to clients over HTTP
* Server an API endpoint that runs the backend code.

## Let's take a look at a static app

First build a basic OpenFaaS function using the dockerfile template:

```bash
# Replace alexellis2 with your Docker Hub username
export OPENFAAS_PREFIX=alexellis2

faas-cli new --lang dockerfile portal
```

This creates:

```bash
portal.yml
portal/Dockerfile
```

See portal.yml:

```yaml
version: 1.0
provider:
  name: openfaas
  gateway: http://127.0.0.1:8080
functions:
  portal:
    lang: dockerfile
    handler: ./portal
    image: alexellis2/portal:latest
```

Whenever we run `faas-cli build` the file in `./portal/Dockerfile` will be used to build a container image named: `alexellis2/portal:latest`.

We can ignore the Dockerfile for now and create the React App.

To create a new static app, first install [Node.js 14 or higher](https://nodejs.org/en/download/) and the npx tool (available with npm 5.2+).

Then generate a new app called portal:

```bash
# The create-react-app will fail due to the folder "portal"
# already existing, so create it in a new folder then move it back 
mkdir app
cd app
npx create-react-app portal

# Move the contents of app/portal into ./portal/

cd ..
mv app/portal/* ./portal

Success! Created portal at /home/alex/go/src/github.com/openfaas/openfaas.github.io/portal/portal/portal
Inside that directory, you can run several commands:

  npm start
    Starts the development server.

  npm run build
    Bundles the app into static files for production.
```

The structure will look like this:

* portal.yml
* portal/Dockerfile
* portal/src/
* portal/package.json
* portal/build/
* portal/node_modules/

Let's try it out directly on our machine without OpenFaaS:

```bash
npm start
```

Access it via `http://127.0.0.1:3000`

![Edit the app](/images/2022-react-app/edit.png)
> Edit the app's source code to customise it

Now let's write a Dockerfile to build the React app into static HTML, and then to serve it.

*portal/Dockerfile*

```Dockerfile
FROM ghcr.io/openfaas/of-watchdog:0.9.2 as watchdog

FROM node:16-alpine as build

WORKDIR /root/

# Turn down the verbosity to default level.
ENV NPM_CONFIG_LOGLEVEL warn

COPY package.json ./

RUN npm i --production

COPY src        ./src
COPY public     ./public

RUN NODE_ENV=production npm run build
RUN find build/

FROM alpine:3.14 AS runtime
WORKDIR /home/app/
RUN addgroup -S -g 1000 app && adduser -S -u 1000 -g app app

COPY --from=build /root/build /home/app/public
WORKDIR /home/app/public

COPY --from=watchdog /fwatchdog /usr/bin/fwatchdog
 
RUN chown app:app -R /home/app \
    && chmod 777 /tmp

USER app

ENV mode="static"
ENV static_path="/home/app/public"

ENV exec_timeout="10s"
ENV write_timeout="11s"
ENV read_timeout="11s"

HEALTHCHECK --interval=5s CMD [ -e /tmp/.lock ] || exit 1

CMD ["fwatchdog"]
```

The first line downloads the OpenFaaS watchdog. This will be used to serve to static HTML, CSS and JS files using a HTTP fileserver. Some people may use Nginx here instead, but it's a little heavy-weight and specialised for our purposes.

Then we set up the Node.js version we need `FROM node:16-alpine as build` - the Alpine image is smaller, and ideal if we have no native npm modules to build like SQLite. Seeing as our code is only front-end based, we shouldn't have to switch.

Notice that we copy package.json before any code. This is a trick to optimize the build. If you remove it then all the dependencies will be downloaded upon every build.

The `RUN NODE_ENV=production npm run build` step builds or "transpiles" the JSX files and other assets into a single directory that will be copied into the final image from `/root/build` to `/home/app/public`.

For the runtime image, we're using `FROM alpine:3.14 AS runtime` which is a minimal Linux Operating System. Distroless could also work here, since the watchdog does all the work we need to serve the files. Note the `ENV static_path="/home/app/public"` value which tells the watchdog where to find the files.

Now run a build and test it out locally, with Docker:

```bash
# Buildkit enables a faster build process
export DOCKER_BUILDKIT=1

faas-cli build -f portal.yml

docker run --name portal-test \
    -p 8080:8080 \
    --rm -ti alexellis2/portal:latest
```

Now access it via port 8080: `http://127.0.0.1:8080`

